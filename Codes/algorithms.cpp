#include "algorithms.h"

void sequenceGen(int* seq, int n){

	std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(1.0, 2.0);
    for (int i = 0; i < n; ++i) {
        // Use dis to transform the random unsigned int generated by gen into a 
        // double in [1, 2). Each call to dis(gen) generates a new random double
        //std::cout << dis(gen) << ' ';
        if(dis(gen)<1.5)
        	seq[i]=-1;
        else
        	seq[i]=1;
    }
    // std::cout << '\n';
    // for (int i = 0; i < n; ++i)
    // 	cout << seq[i] << ' ';
}

double simulatedAnealing(int* seq, int n, int NOfIter){
	int y[n];
	double temp,bestMerit,curMerit;
	double proba;
	int randNum;
	bestMerit=meritfactor(seq,n);
	curMerit=bestMerit;
	int l=0,indx;
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    //cout << "n :"<<n<<endl;
    while(true){
    	l++;
    	if(l>NOfIter)
    		break;

	    std::uniform_int_distribution<> dis(1.0, n);
	    indx=dis(gen)-1;
	    y[indx]=seq[indx];
	    seq[indx]=(seq[indx]==-1)?1:-1;
	    temp=meritfactor(seq,n);
	    proba=fmin(1,exp(temp-curMerit)*(1*log(l)));
	    //cout<<" temp"<<temp<<endl;
	    randNum=rand()%100;
	    if(temp>curMerit){
	    	curMerit=temp;
	    	seq[indx]=y[indx];
	    	if (curMerit>bestMerit){
	    		bestMerit=curMerit;
	    	}
	    }
	    if((randNum<=100*proba)){
	    	seq[indx]=y[indx];
	    	curMerit=temp;
	    }

	}
	return bestMerit;

}
double OneOneEA_1(int* seq, int n, int NOfIter) {
	double merit=meritfactor(seq,n);
	double temp=0;
	int y[n];
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	for(int l=0;l<NOfIter;l++){
		//cout<<" NOfIter: "<<l<<endl;
		for (int i = 0; i < n; ++i)
		{	
			
		    std::uniform_real_distribution<> dis(1.0, n);
		    if(dis(gen)<2)
		    	y[i]=(seq[i]==1)?-1:1;
		    else
		    	y[i]=seq[i];
		}
		//cout<<"out of inside loop";
		temp=meritfactor(y,n);
		//cout <<" temp"<<temp;
		if(temp>merit){
			merit=temp;
			for (int i = 0; i < n; ++i)
				seq[i]=y[i];
		}
		//cout<<"llll" <<l;
	}
	//cout<<"kollan outside loop"<<NOfIter<<"merit: "<<merit;
	return merit;
}
double OneOneEA_2(int* seq, int n, int NOfIter) {
	double merit=meritfactor(seq,n);
	double temp=0;
	int y[n];
	//double opt=(n%2==0)?n:(pow(n,2)/n-1);
	int l=0;
	// reachTarget=1;
	// int iterationNum=pow(2,n);
	// if(iterationNum<NOfIter)
	// 	NOfIter=iterationNum;
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	while(true){
		//cout<<" NOfIter: "<<l<<endl;
		if(l>NOfIter){
			break;
		}  
		// if((merit>(0.7*opt)) && n>20){
		// 	reachTarget=1;
		// 	break;
		// }
		l++;
		for (int i = 0; i < n; ++i)
		{	
		    std::uniform_real_distribution<> dis(1.0, n);
		    if(dis(gen)<2)
		    	y[i]=(seq[i]==1)?-1:1;
		    else
		    	y[i]=seq[i];
		}
		//cout<<"out of inside loop";
		temp=meritfactor(y,n);
		//cout<<n <<" l"<<l <<" temp"<<temp<<" "<<merit<<endl;
		if(temp>merit){
			merit=temp;
			for (int i = 0; i < n; ++i)
				seq[i]=y[i];
		}
		//cout<<"llll" <<l;
	}
	//cout<<"kollan outside loop"<<NOfIter<<"merit: "<<merit;
	return merit;
}

void addition (int a[], int b[], int sizea, int sizeb, int result[]){

    int maxSize = sizea > sizeb ? sizea : sizeb;  // number of bits is maximum of siza and sizeb

    int carry = 0;
    for( int i = 0; i < maxSize; i++ )
    {
        int bitA = i < sizea && a[i] ? 1 : 0;     // test if bit in array a is set
        int bitB = i < sizeb && b[i] ? 1 : 0;     // test if bit in array b is set
        int sum = bitA + bitB + carry;            // calculate sum of all bits
        result[i] = sum == 1 || sum == 3 ? 1 : 0; // result bit is set if sum is equal 1 or 3
        carry = sum > 1 ? 1 : 0;                  // carry bit is set if sum is eaul 2 or 3
    }
    //result[ maxSize ] = carry;                    // highest bit of result is carry bit

    // for (int i = 0; i < maxSize; i++){
    //     cout << result[maxSize-1-i];
    // }
}

double exhustiveSearch(int* seq, int n){
	int b[n];
	int a[n];
	int sol[n];
	b[0]=1;a[0]=0;
	for (int i=1;i<n;i++){
		b[i]=0;a[i]=0;
	}
	double merit=meritfactor(seq,n);
	double temp=0;
	for (int j = 0; j < pow(2,n); j++){
		
		addition(a,b,n,n,a);
		for (int i=0;i<n;i++){
			seq[i]=(a[i]==1) ? 1 : -1;
		}
		temp=meritfactor(seq,n);
		if(temp>merit){
			merit=temp;
			for (int ind = 0; ind < n; ind++){
				sol[ind]=seq[ind];
			}
		}
	}
	for (int ind = 0; ind < n; ind++){
		seq[ind]=sol[ind];
	}
	return merit;
}










